using Biohazrd.OutputGeneration.Tests;
using Biohazrd.Tests.Common;
using Xunit;

namespace Biohazrd.CSharp.Tests
{
    public sealed class CSharpCodeWriterTests : BiohazrdCodeWriterTestBase<CSharpCodeWriter>
    {
        private const string AutoGeneratedPrefix = "// <auto-generated />\n#nullable enable\n";

        [Fact]
        [RelatedIssue("https://github.com/InfectedLibraries/Biohazrd/issues/149")]
        public void HeaderComment()
        {
            CodeWriterTest
            (
@"// <auto-generated>
// GENERATED
// FILE
// </auto-generated>
#nullable enable
using System;

Console.WriteLine(""Hello, world!"");
",
                session => session.GeneratedFileHeader = "GENERATED\nFILE",
                writer =>
                {
                    writer.Using("System"); // Console
                    writer.WriteLine(@"Console.WriteLine(""Hello, world!"");");
                }
            );
        }

        [Fact]
        [RelatedIssue("https://github.com/InfectedLibraries/Biohazrd/issues/149")]
        public void AutoGeneratedEvenWithoutHeaderComment()
        {
            CodeWriterTest
            (
@"// <auto-generated />
#nullable enable
",
                writer => { }
            );
        }

        [Fact]
        public void Using()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"using System;

Console.WriteLine(""Hello, world!"");
",
                writer =>
                {
                    writer.WriteLine("Console.WriteLine(\"Hello, world!\");");
                    writer.Using("System"); // Intentionally add the using after writing code to show it goes to the top of the file
                }
            );
        }

        [Fact]
        public void UsingsAreSorted()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"using A;
using B;
using C;

Console.WriteLine(""Hello, world!"");
",
                writer =>
                {
                    writer.WriteLine("Console.WriteLine(\"Hello, world!\");");
                    writer.Using("B");
                    writer.Using("C");
                    writer.Using("A");
                }
            );
        }

        [Fact]
        public void UsingsAreDeduplicated()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"using Test1;
using Test2;

Console.WriteLine(""Hello, world!"");
",
                writer =>
                {
                    writer.WriteLine("Console.WriteLine(\"Hello, world!\");");
                    writer.Using("Test1");
                    writer.Using("Test2");

                    writer.Using("Test1");
                    writer.Using("Test2");
                }
            );
        }

        [Fact]
        public void UsingsDeduplicationIsCaseSensitive()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
// You might expect this to be Test1, TEST1, Test2 TEST2 if you expected ordinal sorting, but we use InvariantCulture which apparently sorts this way.
// This is consistent with Visual Studio's "Remove and Sort Usings" feature, so I think this is reasonable.
@"using Test1;
using TEST1;
using Test2;
using TEST2;

Console.WriteLine(""Hello, world!"");
",
                writer =>
                {
                    writer.WriteLine("Console.WriteLine(\"Hello, world!\");");
                    writer.Using("Test1");
                    writer.Using("Test2");
                    writer.Using("TEST1");
                    writer.Using("TEST2");

                    writer.Using("Test1");
                    writer.Using("Test2");
                    writer.Using("TEST1");
                    writer.Using("TEST2");
                }
            );
        }

        [Fact]
        public void DisableScope()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
// The extra newline after LINE1 may seem odd, but the DisabledScope ensures separation since it's intended to be used to disable a declaration
@"LINE1

#if false
DISABLED1
DISABLED2
#endif
LINE2
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    using (writer.DisableScope())
                    {
                        writer.EnsureSeparation(); // This is expected to do nothing since we're "part" of the disabled block
                        writer.WriteLine("DISABLED1");
                        writer.WriteLine("DISABLED2");
                    }
                    writer.WriteLine("LINE2");
                }
            );
        }

        [Fact]
        public void DisableScope_NoSeparation()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"LINE1
#if false
DISABLED1
DISABLED2
#endif
LINE2
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    writer.NoSeparationNeededBeforeNextLine();
                    using (writer.DisableScope())
                    {
                        writer.EnsureSeparation(); // This is expected to do nothing since we're "part" of the disabled block
                        writer.WriteLine("DISABLED1");
                        writer.WriteLine("DISABLED2");
                    }
                    writer.WriteLine("LINE2");
                }
            );
        }

        [Fact]
        public void DisableScope_Message()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"LINE1

#if false // MESSAGE
DISABLED1
DISABLED2
#endif
LINE2
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    using (writer.DisableScope("MESSAGE"))
                    {
                        writer.WriteLine("DISABLED1");
                        writer.WriteLine("DISABLED2");
                    }
                    writer.WriteLine("LINE2");
                }
            );
        }

        [Fact]
        public void DisableScope_Indented()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"LINE1
    LINE2

#if false // MESSAGE
    DISABLED1
    DISABLED2
#endif
    LINE3
LINE4
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    using (writer.Indent())
                    {
                        writer.WriteLine("LINE2");
                        using (writer.DisableScope("MESSAGE"))
                        {
                            writer.WriteLine("DISABLED1");
                            writer.WriteLine("DISABLED2");
                        }
                        writer.WriteLine("LINE3");
                    }
                    writer.WriteLine("LINE4");
                }
            );
        }

        [Fact]
        public void DisableScope_NoDisable()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"LINE1
DISABLED1
DISABLED2
LINE2
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    using (writer.DisableScope(false, "MESSAGE"))
                    {
                        writer.WriteLine("DISABLED1");
                        writer.WriteLine("DISABLED2");
                    }
                    writer.WriteLine("LINE2");
                }
            );
        }

        [Fact]
        public void DisableScope_NoDisableEnsureSeparation()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix +
@"LINE1

DISABLED1
DISABLED2
LINE2
",
                writer =>
                {
                    writer.WriteLine("LINE1");
                    using (writer.DisableScope(false, "MESSAGE"))
                    {
                        writer.EnsureSeparation();
                        writer.WriteLine("DISABLED1");
                        writer.WriteLine("DISABLED2");
                    }
                    writer.WriteLine("LINE2");
                }
            );
        }

        [Fact]
        public void WriteIdentifier_Basic()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix + "MyClass",
                writer => writer.WriteIdentifier("MyClass")
            );
        }

        [Fact]
        public void WriteIdentifier_Keyword()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix + "@class",
                writer => writer.WriteIdentifier("class")
            );
        }

        [Fact]
        public void WriteIdentifier_IllegalCharacter()
        {
            CodeWriterTest
            (
                AutoGeneratedPrefix + "MyClass__UNICODE_0021__",
                writer => writer.WriteIdentifier("MyClass!")
            );
        }

        [Fact]
        public void SanitizeIdentifier_Basic()
            => Assert.Equal("MyClass", CSharpCodeWriter.SanitizeIdentifier("MyClass"));

        [Fact]
        public void SanitizeIdentifier_Keyword()
        {
            Assert.Equal("@class", CSharpCodeWriter.SanitizeIdentifier("class"));
            Assert.Equal("@if", CSharpCodeWriter.SanitizeIdentifier("if"));
            Assert.Equal("@virtual", CSharpCodeWriter.SanitizeIdentifier("virtual"));
            Assert.Equal("@namespace", CSharpCodeWriter.SanitizeIdentifier("namespace"));
            Assert.Equal("@in", CSharpCodeWriter.SanitizeIdentifier("in"));
        }

        [Fact]
        public void SanitizeIdentifier_IllegalCharacters()
            => Assert.Equal("MyClass__UNICODE_003F__", CSharpCodeWriter.SanitizeIdentifier("MyClass?"));

        [Fact]
        public void IsLegalIdentifier_Basic()
            => Assert.True(CSharpCodeWriter.IsLegalIdentifier("MyClass"));

        [Fact]
        public void IsLegalIdentifier_Keyword()
            // Keywords are considered legal since they can be written out in a sensible manner
            => Assert.True(CSharpCodeWriter.IsLegalIdentifier("class"));

        [Fact]
        public void IsLegalIdentifier_IllegalCharacters()
            => Assert.False(CSharpCodeWriter.IsLegalIdentifier("MyClass?"));

        [Fact]
        public void SanitizeStringLiteral_Basic()
            => Assert.Equal("Hello, world!", CSharpCodeWriter.SanitizeStringLiteral("Hello, world!"));

        [Fact]
        public void SanitizeStringLiteral_EmbeddedQuote()
            => Assert.Equal(@"Hello, \""world\""!", CSharpCodeWriter.SanitizeStringLiteral("Hello, \"world\"!"));

        [Fact]
        public void SanitizeStringLiteral_Backslash()
            => Assert.Equal(@"Hello You\\World!", CSharpCodeWriter.SanitizeStringLiteral("Hello You\\World!"));

        [Fact]
        public void SanitizeStringLiteral_WellKnownUnprintables()
            => Assert.Equal(@"\0\a\b\f\t\v", CSharpCodeWriter.SanitizeStringLiteral("\0\a\b\f\t\v"));

        [Fact]
        public void SanitizeStringLiteral_LineTerminators()
            => Assert.Equal(@"\r\n\x0085\x2028\x2029", CSharpCodeWriter.SanitizeStringLiteral("\r\n\x0085\x2028\x2029"));

        [Fact]
        public void SanitizeStringLiteral_AnnoyingToPrint()
        {
            // None of these strictly have to be escape as per the C# spec, but they tend to be problematic to have embedded directly in code
            // because they don't render in all editors or they're invisible by nature.

            // ZERO WIDTH SPACE
            Assert.Equal(@"\x200B", CSharpCodeWriter.SanitizeStringLiteral("\u200B"));

            // Private Use, First
            Assert.Equal(@"\xE000", CSharpCodeWriter.SanitizeStringLiteral("\uE000"));

            // Plane 16 Private Use, First
            Assert.Equal(@"\xDBC0\xDC00", CSharpCodeWriter.SanitizeStringLiteral("\uDBC0\uDC00"));

            // WOMAN + EMOJI MODIFIER FITZPATRICK TYPE-5 + ZERO WIDTH JOINER + PERSONAL COMPUTER = The woman technologist emoji with medium-dark skin
            Assert.Equal(@"\xD83D\xDC69\xD83C\xDFFE\x200D\xD83D\xDCBB", CSharpCodeWriter.SanitizeStringLiteral("\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDCBB"));
        }

        [Fact]
        public void SanitizeMulitlineComment_NothingToDo()
            => Assert.Equal("Hello, world!", CSharpCodeWriter.SanitizeMultiLineComment("Hello, world!"));

        [Fact]
        public void SanitizeMulitlineComment_CommentWithin()
            /* C# provides no real means for escaping a multi-line comment within a multi-line comment
             * This helper function is proided purely for robustness purposes. In the rare case a string that will be written as a multi-line comment contains a *​/
             * we need to do something about it. The something we do is that we insert a zero-width space to "break" the end of the multi-line comment.         (^__Just like this)
             * This is generally invisible to developers looking at the code in an editor and allows the code to still compile.
             */
            => Assert.Equal("Hello, /* Test *\x200B/ world!", CSharpCodeWriter.SanitizeMultiLineComment("Hello, /* Test */ world!"));
    }
}
